# enum
enumが値を持つことができるので、cより構造体的に使うことができる。

# Result
エラーハンドリング処理を簡潔に書くための、enum(メンバはOkとErr)
<br>
match文で、正常とエラーの処理の書き分けができる

# Option
値が存在するかどうかを表す列挙型。(Some(T)またはNone)
<br>
Resultと同様にmatch文でその後の処理の書き分けができる。
これもエラー処理の書き分けに使える
<br>
nullの可能性がある場面でのポインタ(Box)は、Optionを使う。
シンプルなBoxだとnull値がnullであることは許されない


# ジェネリック型
```T``` 
<br>
全ての型というのを表す。

# Annotの使い方
newをやってくれる共通のデータ構造(ジェネリック型メンバ変数を持つことで、何でも含むことができる。)
<br>
ジェネリック型のメインデータ構造のほかに、共通のメンバ変数を持たせるという使い方もできる。

# 代入
copy traitのないオブジェクトの代入とかは面倒なことになるので、オブジェクト指向的にimplとメンバ変数を使って実現するのが良い？

# ライフタイム注釈
関数が複数の参照を引数に取りそのどちらかを返す時など、コンパイラがライフタイムを推論できない時につける必要がある。
(型を明示する必要がある時に型注釈をつけるのと似てる)
<br>
参照を返す関数とかでよく使う
<br>
この関数の返り値はこの参照と同じだけ生きるよ、と言う意味で使われることが多い。
<br>

- 注釈が必要かどうか:複数の参照のどちらかを返したりしてるかで判断される
- 注釈をつけた結果期限切れになってないかどうか:同じ注釈がつけられた参照の中の期限切れ最短の参照が、使われるところで期限切れになってるかで判断される
これによって、実は参照切れだったということを防ぐ

# エラー
エラー情報は様々な関数に受け渡されるため、エラーの中身にコピートレイトのないものを入れると面倒くさい

# テスト
testによく使われているassert_eq!というマクロは
```
assert_eq!(func(param),return_val)
```
という風に書く


# 電卓設計の反省
- 構文木に関して、expr/term/factorとかに分けなくても、木の形だけで計算順を表すことができた
- 逆に木の形の設計に関しては、先にもっと色々シミュレーションしながら考えるべきだった

